@inherits TemplatePage<CsharpMethod>
@using System
@using System.Linq
@using System.Collections.Generic
@using RazorLight
@using ApiGenerator.Domain
@{
	CsharpMethod method = Model;
	var type = method.DescriptorType + method.DescriptorTypeGeneric;
	var concreteInterface = method.InterfaceTypeGeneric == null ? method.InterfaceType : method.InterfaceTypeGeneric;
}
	///<summary>descriptor for @method.FullName <pre>@method.Documentation</pre></summary>
	public partial class @Raw(type) @(Raw(string.Format(" : RequestDescriptorBase<{0},{1}, {2}>, {2}", type, method.QueryStringParamName, concreteInterface)))
	{ 
		internal override ApiUrls ApiUrls => @(Raw(method.RequestType)).Urls;
@foreach (Constructor c in Constructor.DescriptorConstructors(method))
{
<text>		@(Raw(CodeGenerator.Constructor(c)))
</text>
}
		// values part of the url path
@foreach (UrlPart part in method.Url.ExposedApiParts)
{
<text>		@(Raw(part.ClrTypeName)) @(Raw(method.InterfaceType)).@(part.InterfaceName) => Self.RouteValues.Get@(Raw(string.Format("<{0}>",part.ClrTypeName)))("@(part.Name)");
</text>
}
@foreach (FluentRouteSetter c in method.GetFluentRouteSetters())
{
<text>
		@(Raw(c.XmlDoc))
		@(Raw(c.Code))
</text>
}
		// Request parameters
@foreach (var param in method.Url.Params.Values)
{
	var original = param.QueryStringKey;
	//skip parameters already part of the path portion of the url
	if (method.Url.ExposedApiParts.Any(p=>p.Name == original))
	{
		continue;
	}
	//we prefer this parameter to be explictly implemented on the request body
	if (param.RenderPartial && (method.HasBody))
	{
		continue;
	}
	var t = @param.TypeHighLevel;
	var tSuffix = (t == "bool" || t == "bool?") ? " = true" : "";
	var typed = !string.IsNullOrEmpty(method.DescriptorTypeGeneric);
	var g = typed ? method.DescriptorTypeGeneric.Replace("<", "").Replace(">", "") : "T";
	var desc = param.DescriptionHighLevel.ToList();
	
	await IncludeAsync("Shared/XmlDocs.cshtml", desc);
	if(!string.IsNullOrWhiteSpace(param.Obsolete))
	{
<text>		[Obsolete("Scheduled to be removed in 7.0, @param.Obsolete")]
</text>
	}
<text>
		public @Raw(type) @(param.ClsName)(@param.DescriptorArgumentType @param.ClsArgumentName@tSuffix) => Qs("@original", @(param.ClsArgumentName));
</text>
	if (param.IsFieldsParam)
	{
<text>
		///<summary>@param.Description</summary>
		public @Raw(type) @param.ClsName@(Raw(typed ? "" : "<T>"))(params @Raw("Expression<Func<" + g + ", object>>[]") fields) @Raw(typed ? "" : "where " + g + " : class") => Qs("@original", fields?@Raw(".Select(e=>(Field)e)"));
</text>
	}
	else if (param.IsFieldParam)
	{
<text>
		///<summary>@param.Description</summary>
		public @Raw(type) @param.ClsName@(Raw(typed ? "" : "<T>"))(@Raw("Expression<Func<"+ g +", object>>") field) @Raw(typed ? "" : "where " + g + " : class") => Qs("@original", (Field)field);
</text>
	}
}
	@if (method.Unmapped)
	{<text>
		//TODO THIS METHOD IS UNMAPPED!
		</text>
	}	
	}

